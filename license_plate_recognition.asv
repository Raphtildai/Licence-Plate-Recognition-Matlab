function [recognized_chars, time_taken] = license_plate_recognition()
% ======================================================================
% LICENSE PLATE RECOGNITION (LPR)
% ======================================================================
    tic; % Start timer for comparison
    clc; clear; close all;
    
    %% -------------------- 0. Load Character Database --------------------
    try
        load('templates/imgfildata.mat');
        if ~exist('imgfile', 'var')
            error('imgfildata.mat must contain imgfile variable');
        end
        fprintf('Loaded character database with %d templates\n', size(imgfile, 2));
    catch
        error('Could not load imgfildata.mat character database. Ensure it exists.');
    end

    % --- Pre-process templates for consistent size ---
    TEMPLATE_SIZE = [42, 24];
    for t = 1:size(imgfile, 2)
        
        % ********************************************************************
        % Convert to double
        % ********************************************************************
        template_img = imgfile{1, t};
        
        % 1. Convert to double to handle logical/other non-numeric types
        template_img_d = double(template_img); 
        
        % 2. If the template is RGB (3D), convert to grayscale. Otherwise, it's 2D.
        if size(template_img_d, 3) == 3
            template_img_d = im2gray(template_img_d);
        end
        
        % 3. Binarize (only necessary if templates weren't already perfectly binary)
        % imbinarize handles numeric arrays well.
        template_binary = imbinarize(template_img_d);
        
        % 4. Resize and store
        imgfile{1, t} = imresize(template_binary, TEMPLATE_SIZE);
        
    end

    %% -------------------- 1. LOAD IMAGE + RGB → GRAY --------------------
    [file, path] = uigetfile({'*.jpg;*.bmp;*.png;*.tif;*.jpeg'}, 'Choose an image');
    if isequal(file, 0)
        disp('No file selected. Exiting.');
        recognized_chars = '';
        time_taken = toc;
        return;
    end
    imgPath = fullfile(path, file);
    
    I_color = imread(imgPath);
    
    % Use built-in function for efficiency and accuracy
    I = im2gray(I_color);
    I = uint8(I);
    figure; imshow(I); title('1. Original Grayscale');

    %% -------------------- 2. CONTRAST ENHANCEMENT --------------------
    % Use Adaptive Histogram Equalization (CLAHE) for better local contrast
    I_enh = adapthisteq(I);
    figure; imshow(I_enh); title('2. Contrast Enhanced (CLAHE)');
    
    %% -------------------- 3. SOBEL EDGE DETECTION  --------------------
    % Using a threshold to create a binary edge map
    E = edge(I_enh, 'sobel');
    figure; imshow(E); title('3. Edges (Sobel)');
    
    %% -------------------- 4. MORPHOLOGICAL CLOSING  --------------------
    SE = strel('square', 3);
    Ec = imclose(E, SE); 
    figure; imshow(Ec); title('4. After Closing');
    
    %% -------------------- 5. CONNECTED COMPONENTS  --------------------
    CC = bwconncomp(Ec);
    % Using regionprops for fast calculation of properties
    props = regionprops(CC, 'Area', 'BoundingBox');
    
    %% -------------------- 6. LICENSE PLATE CANDIDATE SELECTION --------------------
    bestScore = -inf;
    bestBox   = [];
    
    for k = 1:length(props)
        bb = props(k).BoundingBox;
        area = props(k).Area;
        w = bb(3); h = bb(4);
        aspect = w / h;
        
        % Filtering Criteria 
        if aspect < 2 || aspect > 6, continue; end
        if area < 1500 || area > 40000, continue; end

        % Score based on edge density
        sub_image_E = E(round(bb(2)):round(bb(2)+h-1), round(bb(1)):round(bb(1)+w-1));
        score = sum(sub_image_E(:)) / (w * h);
        
        if score > bestScore
            bestScore = score;
            bestBox = bb;
        end
    end
    
    if isempty(bestBox)
        error('No license-plate region detected.');
    end
    
    % Display detected plate
    figure; imshow(I_color); title('6. Detected License Plate'); hold on;
    rectangle('Position', bestBox, 'EdgeColor','red', 'LineWidth', 3);
    hold off;
    
    x1 = round(bestBox(1));
    y1 = round(bestBox(2));
    x2 = x1 + round(bestBox(3)) - 1;
    y2 = y1 + round(bestBox(4)) - 1;
    
    %% -------------------- 7. EXTRACT PLATE --------------------
    width  = bestBox(3);
    height = bestBox(4);
    
    padX = max(round(width * 0.20), 20);
    padY = max(round(height * 0.25), 15);
    
    x1p = max(1, x1 - padX);
    y1p = max(1, y1 - padY);
    x2p = min(size(I_enh,2), x2 + padX);
    y2p = min(size(I_enh,1), y2 + padY);
    
    plate = I_enh(y1p:y2p, x1p:x2p);
    
    % SAFE EXTRA CROP TO REMOVE THICK BORDER
    if size(plate,1) > 12 && size(plate,2) > 12
        plate = plate(6:end-6, 6:end-6);
    end

    figure; imshow(plate); title('7. Extracted Plate');
    
    %% -------------------- 8. OTSU + BORDER REMOVAL + CLEANING --------------------
    th = graythresh(plate);
    BW = imbinarize(plate, th);
    BW = ~BW;                 % characters white
    
    % 1. Clean noise by removing small isolated components.
    BW_cleaned = bwareaopen(BW, 40); 
    
    % 2. Use imclearborder to remove frame/border elements
    BW_cleaned = imclearborder(BW_cleaned);
    
    % 3. GENTLE morphological operations on the *cleaned* image
    % Closing small gaps within characters
    BW_morph = imclose(BW_cleaned, strel('rectangle', [2, 1]));
    
    % Light dilation to connect broken parts
    BW_morph = imdilate(BW_morph, strel('square', 1));
    
    % Remove any remaining small noise after morphology
    BW = bwareaopen(BW_morph, 35); % Final cleanup
        
    figure; imshow(BW); title('8. Clean Binarized Plate');
    
    %% -------------------- 9. CHARACTER SEGMENTATION + MERGING (FINAL FILTER SET) --------------------
    CC_chars = bwconncomp(BW);
    charStats = regionprops(CC_chars, 'BoundingBox', 'Area');
    
    % Display all detected components for debugging
    fprintf('\n=== ALL DETECTED COMPONENTS ===\n');
    for k = 1:length(charStats)
        bb = charStats(k).BoundingBox;
        w = bb(3); h = bb(4);
        aspect = w/h;
        area = charStats(k).Area;
        fprintf('Component %d: x=%.1f, w=%.1f, h=%.1f, aspect=%.2f, area=%.0f\n', ...
                k, bb(1), w, h, aspect, area);
    end
    
    charBoxes = [];
    plate_height = size(BW, 1);
    plate_width = size(BW, 2);
    
    % Calculate average character height from the largest components
    all_heights = [];
    for k = 1:length(charStats)
        bb = charStats(k).BoundingBox;
        h = bb(4);
        area = charStats(k).Area;
        if area > 150  
            all_heights = [all_heights; h];
        end
    end
    
    if ~isempty(all_heights)
        avg_height = median(all_heights);
        fprintf('Median character height: %.1f\n', avg_height);
    else
        avg_height = plate_height * 0.6;
    end
    
    for k = 1:length(charStats)
        bb = charStats(k).BoundingBox;
        w = bb(3); h = bb(4);
        aspect = w/h;
        area = charStats(k).Area;
        
        % Filter 1: Area 
        if area < 150, continue; end  
        
        % Filter 2: Height 
        % Characters should be TALL. Allowing only 65% to 110% of median height.
        % Filter against non-character elements (emblems, dots, dashes).
        min_height = 0.65 * avg_height;
        max_height = 1.10 * avg_height;
        if h < min_height || h > max_height, continue; end 
        
        % Filter 3: Aspect Ratio 
        if aspect < 0.1 || aspect > 1.0, continue; end  
        
        % Filter 4: Width should not be too large (not multiple characters)
        if w > plate_width * 0.20, continue; end
        
        charBoxes = [charBoxes; bb];
    end
    
    % Try to merge characters that might have been split
    if ~isempty(charBoxes)
        % Sort by x-position
        [~, ord] = sort(charBoxes(:,1));
        charBoxes = charBoxes(ord, :);

        % Merge nearby boxes that might be parts of the same character
        mergedBoxes = [];
        i = 1;
        while i <= size(charBoxes, 1)
            current = charBoxes(i, :);
            
            if i < size(charBoxes, 1)
                next = charBoxes(i+1, :);
                gap = next(1) - (current(1) + current(3));
                
                % If boxes are very close AND similar height, check if merging is valid
                if gap < 5 && abs(current(4) - next(4)) < avg_height * 0.3
                    
                    % Check for maximum allowed width after merging
                    x2 = max(current(1) + current(3), next(1) + next(3));
                    x1 = min(current(1), next(1));
                    merged_width = x2 - x1;
                    
                    % --- ONLY MERGE IF THE NEW WIDTH IS ACCEPTABLE ---
                    % A merged character should not be wider than 1.5 times the median height 
                    % (or maybe 1.25 times for safety, since aspect ratio limit is 1.0).
                    if merged_width < 1.25 * avg_height 
                        
                        % Merge the two boxes
                        y1 = min(current(2), next(2));
                        y2 = max(current(2) + current(4), next(2) + next(4));
                        merged = [x1, y1, merged_width, y2-y1];
                        mergedBoxes = [mergedBoxes; merged];
                        i = i + 2;  % Skip the next box since we merged it
                    else
                        % If merging makes the character too wide, treat them as separate
                        mergedBoxes = [mergedBoxes; current];
                        i = i + 1;
                    end
                else
                    mergedBoxes = [mergedBoxes; current];
                    i = i + 1;
                end
            else
                mergedBoxes = [mergedBoxes; current];
                i = i + 1;
            end
        end
        charBoxes = mergedBoxes;
    end
    
    % Get the list of ALL components 
    all_components = regionprops(CC_chars, 'BoundingBox', 'Area', 'Eccentricity');
    
    % Sort segmented character boxes by x-position
    if isempty(charBoxes)
        fprintf('No characters passed filtering after merging. Skipping dash detection and final sort.\n');
    else
        [~, ord] = sort(charBoxes(:,1));
        charBoxes = charBoxes(ord, :);
        
        dash_found = false;
        
        for c = 1:size(charBoxes, 1) - 1
            % Gap region between two segmented characters
            gap_start_x = charBoxes(c, 1) + charBoxes(c, 3);
            gap_end_x = charBoxes(c+1, 1);
            
            % Only check gaps that are reasonably sized (e.g., up to 2.5 times median width)
            if (gap_end_x - gap_start_x) > (charBoxes(c, 3) * 2.5), continue; end
            
            % Search through ALL components to find one that lies in this gap
            for k = 1:length(all_components)
                bb_comp = all_components(k).BoundingBox;
                w_comp = bb_comp(3); h_comp = bb_comp(4);
                area_comp = all_components(k).Area;
                ecc_comp = all_components(k).Eccentricity;
                
                % Check if the component is physically located in the gap
                if bb_comp(1) > gap_start_x && (bb_comp(1) + w_comp) < gap_end_x
                    
                    % DASH/DOT FILTER: Must be small, low-center, and/or long/flat
                    % 1. Small area (was filtered out by area < 150)
                    if area_comp < 150 
                        
                        % 2. Is it a horizontal dash? (High aspect/eccentricity)
                        aspect_comp = w_comp / h_comp;
                        if aspect_comp > 3.0 || ecc_comp > 0.95 % long/flat component
                            
                            % 3. Check for vertical position (mid-height for dash, low for dot)
                            y_center_comp = bb_comp(2) + h_comp / 2;
                            plate_center_y = plate_height / 2;
                            
                            % If it's near the center line, it's a dash
                            if abs(y_center_comp - plate_center_y) < avg_height * 0.2
                                % Found a dash! Insert the original component's bounding box
                                charBoxes = [charBoxes(1:c, :); bb_comp; charBoxes(c+1:end, :)];
                                dash_found = true;
                                break;
                            end
                        end
                    end
                end
            end
            if dash_found, break; end % Exit the outer loop after inserting a dash
        end
    end
    
    % Display segmented characters
    fprintf('\n=== FINAL SEGMENTED CHARACTERS ===\n');
    for k = 1:size(charBoxes,1)
        fprintf('Char %d: x=%.1f, w=%.1f, h=%.1f\n', ...
                k, charBoxes(k,1), charBoxes(k,3), charBoxes(k,4));
    end
    
    figure; imshow(BW); hold on;
    for k = 1:size(charBoxes,1)
        rectangle('Position', charBoxes(k,:), 'EdgeColor','r', 'LineWidth', 2);
    end
    hold off;
    title(sprintf('9. Final Character Segmentation (Detected: %d)', size(charBoxes,1)));

    %% -------------------- 10. CHARACTER RECOGNITION --------------------
    recognized_chars = '';
    
    if isempty(charBoxes)
        fprintf('No characters to recognize.\n');
        time_taken = toc;
        return;
    end
    fprintf('\n=== 10. CHARACTER RECOGNITION ===\n');
    
    for k = 1:size(charBoxes,1)
        bb = charBoxes(k,:);
        
        % Extract character with padding 
        pad_x = max(1, round(bb(3) * 0.1));
        pad_y = max(1, round(bb(4) * 0.1));
        
        x1_c = max(1, round(bb(1)) - pad_x);
        y1_c = max(1, round(bb(2)) - pad_y);
        x2_c = min(size(BW,2), round(bb(1) + bb(3)) + pad_x);    % CHANGE: BW_clean → BW
        y2_c = min(size(BW,1), round(bb(2) + bb(4)) + pad_y);    % CHANGE: BW_clean → BW
        
        char_img = BW(y1_c:y2_c, x1_c:x2_c);                     % CHANGE: BW_clean → BW
        
        if numel(char_img) < 25
            fprintf('Char %d: Too small, skipping\n', k);
            continue;
        end
        
        % Resize to match template size
        char_resized = imresize(char_img, TEMPLATE_SIZE);
        
        % Recognize character using the correlation technique
        [best_char, confidence] = recognize_character_simple_optimized(char_resized, imgfile);
        
        % Adaptive threshold 
        threshold = 0.3;
        if k <= 2 % First two characters (typically letters)
            threshold = 0.35;
        end
        
        if confidence > threshold
            recognized_chars = [recognized_chars, best_char];
            status = 'MATCH';
        else
            recognized_chars = [recognized_chars, '?'];
            status = 'LOW_CONF';
        end
        
        fprintf('Char %d: %s (confidence: %.3f) - %s\n', k, best_char, confidence, status);
    end

    %% -------------------- 11. FINAL RESULTS & BENCHMARK --------------------
    time_taken = toc;
    fprintf('\n=== 11. FINAL RESULT ===\n');
    fprintf('Recognized License Plate: %s\n', recognized_chars);
    fprintf('Total execution time: %.3f seconds\n', time_taken);
    
    % Save to file
    try
        fileID = fopen('number_Plate_Optimized.txt', 'w');
        fprintf(fileID, '%s\n', recognized_chars);
        fclose(fileID);
        fprintf('Results saved to number_Plate_Optimized.txt\n');
    catch
        warning('Could not save results to file.');
    end
    
    % Final display 
    figure('Position', [100, 100, 1000, 400]);
    subplot(1,3,1); imshow(I_color); title('Original Image');
    subplot(1,3,2); imshow(plate); title('Extracted Plate');
    subplot(1,3,3); imshow(BW); hold on;    % CHANGE: BW_clean → BW
    for k = 1:size(charBoxes,1)
        rectangle('Position', charBoxes(k,:), 'EdgeColor','r', 'LineWidth', 2);
        if k <= length(recognized_chars)
            text(charBoxes(k,1), charBoxes(k,2)-8, recognized_chars(k), ...
                 'Color', 'g', 'FontSize', 12, 'FontWeight', 'bold');
        end
    end
    title(sprintf('Recognized: %s\nTime: %.3fs', recognized_chars, time_taken));
    hold off;
end

%% ===================== HELPER FUNCTION ==============================

function [best_char, best_score] = recognize_character_simple_optimized(char_img, imgfile)
% Simple character recognition using correlation 
% char_img is already resized to TEMPLATE_SIZE
    best_score = -inf;
    best_char = '?';
    
    % Convert to double once outside the loop
    char_img_d = double(char_img); 
    
    for t = 1:size(imgfile, 2)
        % Template is already pre-resized and converted
        template = imgfile{1, t}; 
        
        % Calculate correlation
        correlation = corr2(double(template), char_img_d);
        
        if correlation > best_score
            best_score = correlation;
            best_char = imgfile{2, t};
        end
    end
end